{"version":3,"file":"promises_1.js","sources":["../src/js/promises_1.js"],"sourcesContent":["/*\nПроміс (від англ. Promise — обіцянка) — це об'єкт-замінник, який повертається одразу після початку асинхронної операції і слугує контейнером для її майбутнього результату.\n\nПростіше кажучи, проміс — це об'єкт-заглушка для значення, яке може бути доступне або в майбутньому, або ніколи.\n*/\n\n//Життєвий Цикл Проміса\n\n/*\nПроміс завжди перебуває в одному з трьох станів. Це його життєвий цикл:\n\npending (Очікування): Початковий стан. Операція ще не завершена. Проміс знаходиться в очікуванні, і результат (значення або помилка) ще невідомий.\n\nfulfilled (Виконано/Успіх): Операція завершилася успішно. Проміс переходить у цей стан, і ми отримуємо кінцеве значення (результат).\n\nrejected (Відхилено/Помилка): Операція завершилася з помилкою. Проміс переходить у цей стан, і ми отримуємо об'єкт помилки (причину відхилення).\n\n   Важливо: Проміс може перейти зі стану pending у стан fulfilled або rejected лише один раз. Після цього він вважається врегульованим (settled) і більше не може змінити свій стан.\n*/\n\n// Створення Проміса\n\n/*\nПроміс створюється за допомогою конструктора new Promise(), який приймає єдину функцію-виконавець (executor):\n*/\n\nconst myFirstPromise = new Promise((resolve, reject) => {\n  // Функція-виконавець\n  console.log('Починаємо асинхронну операцію...');\n\n  // Імітуємо затримку (наприклад, мережевий запит)\n  setTimeout(() => {\n    const success = true; // Умова успіху\n\n    if (success) {\n      // Якщо успіх, викликаємо resolve() зі значенням\n      resolve('Дані завантажено успішно!');\n    } else {\n      // Якщо помилка, викликаємо reject() з об'єктом помилки\n      reject(new Error('Помилка завантаження даних!'));\n    }\n  }, 2000); // 2 секунди затримки\n});\n\nconsole.log('myFirstPromise:', myFirstPromise);\n\n/*\nСама функція-виконавець (executor) — це та анонімна стрілкова функція, яка приймає два аргументи: (resolve, reject).\n\nФункція-виконавець=(resolve,reject)⇒{Тіло функції}\n\nФункція-виконавець (Executor): Це функція, яка виконується негайно при створенні проміса. Її завдання — запустити асинхронну операцію і, після її завершення, викликати одну з функцій: resolve або reject.\n*/\n\n// **************************************\n//Функція як Аргумент Конструктора Promise\n\n/*\nnew Promise(функція-виконавець)\n\nФункція-Виконавець (Executor Function) — Це Аргумент\n\nКонструктор Promise — це new Promise.\nАргумент — це вся стрілкова функція (resolve, reject) => { ... }.\n\nФункція-виконавець, яку ми передаємо (наш аргумент), сама має два параметри:\n\nФункція-виконавець(resolve,reject)\n\nresolve: Параметр, який є функцією.\nreject: Параметр, який є функцією.\n*/\n\n// Конструктор Promise приймає цю АНОНІМНУ ФУНКЦІЮ як єдиний аргумент.\nconst myPromise = new Promise((resolve, reject) => {\n  // Тіло функції-виконавця\n  setTimeout(() => {\n    resolve('Успіх!');\n  }, 1000);\n});\n\nconsole.log('*******************');\n/*\nconsole.log(1);\n\nconst p = new Promise((resolve, reject) => {\n  console.log(2); // Виконується негайно\n  setTimeout(() => {\n    console.log(3); // Виконується асинхронно, через 0 мс\n    resolve(4);\n  }, 0);\n});\n\nconsole.log(5);\n// Результат: 1, 2, 5, 3\n*/\n//***************************** */\n\n// Обробка Результату: Методи .then(), .catch(), .finally()\n\n//Метод .then()\n\n/*\nМетод .then() використовується для обробки успішного результату (fulfilled) та створення ланцюжка промісів.\n*/\n/*\nmyFirstPromise.then(\n  // 1. Функція успіху (викликається при resolve)\n  result => {\n    console.log('Успіх! Отримано результат:', result); // \"Дані завантажено успішно!\"\n  },\n  // 2. Функція помилки (викликається при reject) - НЕ РЕКОМЕНДУЄТЬСЯ\n  error => {\n    console.error('Помилка! Причина:', error.message);\n  }\n);\n*/\n//Метод .catch()\n\n// Метод .catch() використовується для обробки помилок (rejected) у всьому ланцюжку промісів.\n\n/*\nmyFirstPromise\n  .then(data => {\n    console.log(data);\n    // Імітуємо помилку на цьому етапі\n    throw new Error('Помилка під час обробки даних!');\n  })\n  .catch(error => {\n    // Обробляє помилки як з myFirstPromise, так і з попереднього .then\n    console.error('Сталася глобальна помилка:', error.message);\n  });\n*/\n\n// Метод.finally();\n\n/*\nМетод .finally() викликається, коли проміс стає врегульованим (settled), незалежно від того, успішний він (fulfilled) чи відхилений (rejected).\n*/\n/*\nmyFirstPromise\n  .then(result => console.log('Успіх:', result))\n  .catch(error => console.error('Помилка:', error.message))\n  .finally(() => {\n    console.log('Операція завершена.');\n    // Тут немає аргументів, оскільки нам не потрібен результат чи помилка\n  });\n*/\n//Ланцюжки Промісів (Promise Chaining)\n\n/*\nОскільки .then() завжди повертає новий проміс, це дозволяє створювати ланцюжки послідовних асинхронних операцій:\n*/\n/*\nmyFirstPromise\n  .then(data => {\n    console.log('Перший крок. Дані:', data);\n    // Повернення нового значення для наступного .then\n    return data.toUpperCase();\n  })\n  .then(processedData => {\n    console.log('Другий крок. Оброблені дані:', processedData);\n    // Тут можна повернути інший проміс, щоб продовжити асинхронний ланцюжок\n    return new Promise(resolve =>\n      setTimeout(() => resolve('Кінець ланцюжка'), 500)\n    );\n  })\n  .then(finalResult => {\n    console.log(finalResult); // \"Кінець ланцюжка\"\n  });\n*/\n// ************************\n// ************************\n\n/*\nІмітація мережевого запиту з успіхом та помилкою\nСтворіть функцію, яка повертає проміс. Проміс має імітувати завантаження даних із затримкою 2 секунди. З 70% ймовірністю він повинен завершитися успіхом (resolve), повертаючи дані, і з 30% — помилкою (reject).\n*/\n/*\nЛогіка вирішення\n\nВикористовуємо new Promise() і setTimeout для імітації затримки.\n\nГенеруємо випадкове число (Math.random()) для визначення успіху/помилки.\n\nЯкщо успіх, викликаємо resolve() з об'єктом даних.\n\nЯкщо помилка, викликаємо reject() з об'єктом Error.\n\nОбробляємо результат за допомогою .then() та .catch().\n*/\n/*\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    // Імітуємо мережеву затримку\n    setTimeout(() => {\n      const isSuccess = Math.random() > 0.3; // 70% успіху\n\n      if (isSuccess) {\n        resolve({ user: 'Alice', id: 101, status: 'loaded' });\n      } else {\n        reject(new Error('Помилка сервера: дані не знайдено.'));\n      }\n    }, 2000);\n  });\n}\n\nfetchData()\n  .then(data => {\n    console.log('✅ Дані отримано:', data);\n  })\n  .catch(error => {\n    console.error('❌ Помилка:', error.message);\n  });\n*/\n/*\nСтворення ланцюжка послідовних операцій\nСтворіть ланцюжок із трьох промісів. Кожен проміс має опрацьовувати результат попереднього. Це імітує послідовні кроки: отримання ID, отримання імені, вітання.\n*/\n\n/*\nЛогіка вирішення\nКожен блок .then() отримує результат попереднього кроку.\n\nЩоб продовжити ланцюжок, then-обробник повинен повернути значення (яке обробляється наступним .then()) або повернути новий Проміс (для наступної асинхронної операції).\n*/\n/*\nfunction getUserId() {\n  return Promise.resolve(42); // Повертає проміс, який одразу успішно виконується\n}\n\n// console.log(getUserId());//{<fulfilled>: 42}\n\nfunction getUserName(id) {\n  console.log(`Крок 1: Отримано ID: ${id}.`);\n  return new Promise(resolve => {\n    setTimeout(() => resolve(`Користувач-${id}`), 500);\n  });\n}\n\ngetUserId()\n  .then(id => getUserName(id)) // Передаємо id наступній функції\n  .then(name => {\n    console.log(`Крок 2: Отримано ім'я: ${name}.`);\n    return `Hello, ${name}!`; // Повертаємо фінальне повідомлення\n  })\n  .then(message => {\n    console.log(`Крок 3: Фінальний результат: ${message}`);\n  })\n  .catch(error => {\n    console.error('❌ Помилка в ланцюжку:', error);\n  });\n*/\n\n//Обробка завершення операції (.finally())\n/*\nСтворіть проміс, який імітує складну операцію. Використовуйте .finally() для виведення повідомлення про завершення, незалежно від успіху чи помилки.\n*/\n/*\nЛогіка вирішення\nПроміс може бути resolved або rejected.\n\n.finally() додається в кінці ланцюжка.\n\nКод у .finally() завжди виконується після resolve або reject, але до наступного синхронного коду.\n*/\n/*\nfunction complexCalculation(data) {\n  return new Promise((resolve, reject) => {\n    console.log('Починаємо складні обчислення...');\n    setTimeout(() => {\n      // Імітуємо помилку\n      const errorOccurred = data.value > 50;\n\n      if (errorOccurred) {\n        reject(new Error('Критична помилка обчислень.'));\n      } else {\n        resolve(data.value * 2);\n      }\n    }, 1500);\n  });\n}\n\n// 1. Сценарій успіху\ncomplexCalculation({ value: 10 })\n  .then(result => console.log('✅ Результат:', result))\n  .catch(error => console.error('❌ Обробка помилки:', error.message))\n  .finally(() => console.log('--- Операцію 1 завершено. ---'));\n\n// 2. Сценарій помилки\ncomplexCalculation({ value: 60 })\n  .then(result => console.log('✅ Результат:', result))\n  .catch(error => console.error('❌ Обробка помилки:', error.message))\n  .finally(() => console.log('--- Операцію 2 завершено. ---'));\n*/\n\n//Створення Проміса з аргументами\n/*\nСтворіть функцію wait(ms), яка повертає проміс, що виконується через задану кількість мілісекунд (ms). Використовуйте деструктуризацію для передачі параметрів.\n*/\n/*\nЛогіка вирішення\nФункція приймає аргумент ms.\n\nВона повертає новий Promise.\n\nДля затримки використовуємо setTimeout(resolve, ms). Оскільки setTimeout може приймати функцію resolve напряму (без аргументів), вона виконається через заданий час.\n*/\n\n// Використовуємо деструктуризацію параметрів для ясності (хоча тут лише один параметр)\nfunction wait({ ms }) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconsole.log('Початок очікування 1.5 секунди...');\n\nwait({ ms: 1500 }) // Виклик функції з об'єктом параметрів\n  .then(() => {\n    console.log('⏰ 1.5 секунди минуло. Проміс виконано!');\n  });\n"],"names":["myFirstPromise","resolve","reject","wait","ms"],"mappings":"oDA0BA,MAAMA,EAAiB,IAAI,QAAQ,CAACC,EAASC,IAAW,CAEtD,QAAQ,IAAI,kCAAkC,EAG9C,WAAW,IAAM,CAKbD,EAAQ,2BAA2B,CAKtC,EAAE,GAAI,CACT,CAAC,EAED,QAAQ,IAAI,kBAAmBD,CAAc,EA8B3B,IAAI,QAAQ,CAACC,EAASC,IAAW,CAEjD,WAAW,IAAM,CACfD,EAAQ,QAAQ,CACjB,EAAE,GAAI,CACT,CAAC,EAED,QAAQ,IAAI,qBAAqB,EAqOjC,SAASE,EAAK,CAAE,GAAAC,GAAM,CACpB,OAAO,IAAI,QAAQH,GAAW,CAC5B,WAAWA,EAASG,CAAE,CAC1B,CAAG,CACH,CAEA,QAAQ,IAAI,mCAAmC,EAE/CD,EAAK,CAAE,GAAI,KAAM,EACd,KAAK,IAAM,CACV,QAAQ,IAAI,wCAAwC,CACxD,CAAG"}