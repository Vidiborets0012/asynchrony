/*
Проміс (від англ. Promise — обіцянка) — це об'єкт-замінник, який повертається одразу після початку асинхронної операції і слугує контейнером для її майбутнього результату.

Простіше кажучи, проміс — це об'єкт-заглушка для значення, яке може бути доступне або в майбутньому, або ніколи.
*/

//Життєвий Цикл Проміса

/*
Проміс завжди перебуває в одному з трьох станів. Це його життєвий цикл:

pending (Очікування): Початковий стан. Операція ще не завершена. Проміс знаходиться в очікуванні, і результат (значення або помилка) ще невідомий.

fulfilled (Виконано/Успіх): Операція завершилася успішно. Проміс переходить у цей стан, і ми отримуємо кінцеве значення (результат).

rejected (Відхилено/Помилка): Операція завершилася з помилкою. Проміс переходить у цей стан, і ми отримуємо об'єкт помилки (причину відхилення).

   Важливо: Проміс може перейти зі стану pending у стан fulfilled або rejected лише один раз. Після цього він вважається врегульованим (settled) і більше не може змінити свій стан.
*/

// Створення Проміса

/*
Проміс створюється за допомогою конструктора new Promise(), який приймає єдину функцію-виконавець (executor):
*/

const myFirstPromise = new Promise((resolve, reject) => {
  // Функція-виконавець
  console.log('Починаємо асинхронну операцію...');

  // Імітуємо затримку (наприклад, мережевий запит)
  setTimeout(() => {
    const success = true; // Умова успіху

    if (success) {
      // Якщо успіх, викликаємо resolve() зі значенням
      resolve('Дані завантажено успішно!');
    } else {
      // Якщо помилка, викликаємо reject() з об'єктом помилки
      reject(new Error('Помилка завантаження даних!'));
    }
  }, 2000); // 2 секунди затримки
});

console.log('myFirstPromise:', myFirstPromise);

/*
Сама функція-виконавець (executor) — це та анонімна стрілкова функція, яка приймає два аргументи: (resolve, reject).

Функція-виконавець=(resolve,reject)⇒{Тіло функції}

Функція-виконавець (Executor): Це функція, яка виконується негайно при створенні проміса. Її завдання — запустити асинхронну операцію і, після її завершення, викликати одну з функцій: resolve або reject.
*/

// **************************************
//Функція як Аргумент Конструктора Promise

/*
new Promise(функція-виконавець)

Функція-Виконавець (Executor Function) — Це Аргумент

Конструктор Promise — це new Promise.
Аргумент — це вся стрілкова функція (resolve, reject) => { ... }.

Функція-виконавець, яку ми передаємо (наш аргумент), сама має два параметри:

Функція-виконавець(resolve,reject)

resolve: Параметр, який є функцією.
reject: Параметр, який є функцією.
*/

// Конструктор Promise приймає цю АНОНІМНУ ФУНКЦІЮ як єдиний аргумент.
const myPromise = new Promise((resolve, reject) => {
  // Тіло функції-виконавця
  setTimeout(() => {
    resolve('Успіх!');
  }, 1000);
});

console.log('*******************');
/*
console.log(1);

const p = new Promise((resolve, reject) => {
  console.log(2); // Виконується негайно
  setTimeout(() => {
    console.log(3); // Виконується асинхронно, через 0 мс
    resolve(4);
  }, 0);
});

console.log(5);
// Результат: 1, 2, 5, 3
*/
//***************************** */

// Обробка Результату: Методи .then(), .catch(), .finally()

//Метод .then()

/*
Метод .then() використовується для обробки успішного результату (fulfilled) та створення ланцюжка промісів.
*/
/*
myFirstPromise.then(
  // 1. Функція успіху (викликається при resolve)
  result => {
    console.log('Успіх! Отримано результат:', result); // "Дані завантажено успішно!"
  },
  // 2. Функція помилки (викликається при reject) - НЕ РЕКОМЕНДУЄТЬСЯ
  error => {
    console.error('Помилка! Причина:', error.message);
  }
);
*/
//Метод .catch()

// Метод .catch() використовується для обробки помилок (rejected) у всьому ланцюжку промісів.

/*
myFirstPromise
  .then(data => {
    console.log(data);
    // Імітуємо помилку на цьому етапі
    throw new Error('Помилка під час обробки даних!');
  })
  .catch(error => {
    // Обробляє помилки як з myFirstPromise, так і з попереднього .then
    console.error('Сталася глобальна помилка:', error.message);
  });
*/

// Метод.finally();

/*
Метод .finally() викликається, коли проміс стає врегульованим (settled), незалежно від того, успішний він (fulfilled) чи відхилений (rejected).
*/
/*
myFirstPromise
  .then(result => console.log('Успіх:', result))
  .catch(error => console.error('Помилка:', error.message))
  .finally(() => {
    console.log('Операція завершена.');
    // Тут немає аргументів, оскільки нам не потрібен результат чи помилка
  });
*/
//Ланцюжки Промісів (Promise Chaining)

/*
Оскільки .then() завжди повертає новий проміс, це дозволяє створювати ланцюжки послідовних асинхронних операцій:
*/
/*
myFirstPromise
  .then(data => {
    console.log('Перший крок. Дані:', data);
    // Повернення нового значення для наступного .then
    return data.toUpperCase();
  })
  .then(processedData => {
    console.log('Другий крок. Оброблені дані:', processedData);
    // Тут можна повернути інший проміс, щоб продовжити асинхронний ланцюжок
    return new Promise(resolve =>
      setTimeout(() => resolve('Кінець ланцюжка'), 500)
    );
  })
  .then(finalResult => {
    console.log(finalResult); // "Кінець ланцюжка"
  });
*/
// ************************
// ************************

/*
Імітація мережевого запиту з успіхом та помилкою
Створіть функцію, яка повертає проміс. Проміс має імітувати завантаження даних із затримкою 2 секунди. З 70% ймовірністю він повинен завершитися успіхом (resolve), повертаючи дані, і з 30% — помилкою (reject).
*/
/*
Логіка вирішення

Використовуємо new Promise() і setTimeout для імітації затримки.

Генеруємо випадкове число (Math.random()) для визначення успіху/помилки.

Якщо успіх, викликаємо resolve() з об'єктом даних.

Якщо помилка, викликаємо reject() з об'єктом Error.

Обробляємо результат за допомогою .then() та .catch().
*/
/*
function fetchData() {
  return new Promise((resolve, reject) => {
    // Імітуємо мережеву затримку
    setTimeout(() => {
      const isSuccess = Math.random() > 0.3; // 70% успіху

      if (isSuccess) {
        resolve({ user: 'Alice', id: 101, status: 'loaded' });
      } else {
        reject(new Error('Помилка сервера: дані не знайдено.'));
      }
    }, 2000);
  });
}

fetchData()
  .then(data => {
    console.log('✅ Дані отримано:', data);
  })
  .catch(error => {
    console.error('❌ Помилка:', error.message);
  });
*/
/*
Створення ланцюжка послідовних операцій
Створіть ланцюжок із трьох промісів. Кожен проміс має опрацьовувати результат попереднього. Це імітує послідовні кроки: отримання ID, отримання імені, вітання.
*/

/*
Логіка вирішення
Кожен блок .then() отримує результат попереднього кроку.

Щоб продовжити ланцюжок, then-обробник повинен повернути значення (яке обробляється наступним .then()) або повернути новий Проміс (для наступної асинхронної операції).
*/
/*
function getUserId() {
  return Promise.resolve(42); // Повертає проміс, який одразу успішно виконується
}

// console.log(getUserId());//{<fulfilled>: 42}

function getUserName(id) {
  console.log(`Крок 1: Отримано ID: ${id}.`);
  return new Promise(resolve => {
    setTimeout(() => resolve(`Користувач-${id}`), 500);
  });
}

getUserId()
  .then(id => getUserName(id)) // Передаємо id наступній функції
  .then(name => {
    console.log(`Крок 2: Отримано ім'я: ${name}.`);
    return `Hello, ${name}!`; // Повертаємо фінальне повідомлення
  })
  .then(message => {
    console.log(`Крок 3: Фінальний результат: ${message}`);
  })
  .catch(error => {
    console.error('❌ Помилка в ланцюжку:', error);
  });
*/

//Обробка завершення операції (.finally())
/*
Створіть проміс, який імітує складну операцію. Використовуйте .finally() для виведення повідомлення про завершення, незалежно від успіху чи помилки.
*/
/*
Логіка вирішення
Проміс може бути resolved або rejected.

.finally() додається в кінці ланцюжка.

Код у .finally() завжди виконується після resolve або reject, але до наступного синхронного коду.
*/
/*
function complexCalculation(data) {
  return new Promise((resolve, reject) => {
    console.log('Починаємо складні обчислення...');
    setTimeout(() => {
      // Імітуємо помилку
      const errorOccurred = data.value > 50;

      if (errorOccurred) {
        reject(new Error('Критична помилка обчислень.'));
      } else {
        resolve(data.value * 2);
      }
    }, 1500);
  });
}

// 1. Сценарій успіху
complexCalculation({ value: 10 })
  .then(result => console.log('✅ Результат:', result))
  .catch(error => console.error('❌ Обробка помилки:', error.message))
  .finally(() => console.log('--- Операцію 1 завершено. ---'));

// 2. Сценарій помилки
complexCalculation({ value: 60 })
  .then(result => console.log('✅ Результат:', result))
  .catch(error => console.error('❌ Обробка помилки:', error.message))
  .finally(() => console.log('--- Операцію 2 завершено. ---'));
*/

//Створення Проміса з аргументами
/*
Створіть функцію wait(ms), яка повертає проміс, що виконується через задану кількість мілісекунд (ms). Використовуйте деструктуризацію для передачі параметрів.
*/
/*
Логіка вирішення
Функція приймає аргумент ms.

Вона повертає новий Promise.

Для затримки використовуємо setTimeout(resolve, ms). Оскільки setTimeout може приймати функцію resolve напряму (без аргументів), вона виконається через заданий час.
*/

// Використовуємо деструктуризацію параметрів для ясності (хоча тут лише один параметр)
function wait({ ms }) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

console.log('Початок очікування 1.5 секунди...');

wait({ ms: 1500 }) // Виклик функції з об'єктом параметрів
  .then(() => {
    console.log('⏰ 1.5 секунди минуло. Проміс виконано!');
  });
